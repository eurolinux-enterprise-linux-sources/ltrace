diff -up ltrace-0.5/sysdeps/linux-gnu/trace.c\~ ltrace-0.5/sysdeps/linux-gnu/trace.c
--- ltrace-0.5/sysdeps/linux-gnu/trace.c~	2012-04-12 11:46:18.954941419 +0200
+++ ltrace-0.5/sysdeps/linux-gnu/trace.c	2012-04-12 16:59:41.136042946 +0200
@@ -169,6 +169,9 @@ struct process_stopping_handler
 	/* The pointer being re-enabled.  */
 	struct breakpoint * breakpoint_being_enabled;
 
+	/* Artificial atomic skip breakpoint, if any needed.  */
+	void *atomic_skip_bp_addr;
+
 	enum {
 		/* We are waiting for everyone to land in t/T.  */
 		psh_stopping = 0,
@@ -523,12 +526,118 @@ all_stops_accountable(struct pid_set * p
 	return 1;
 }
 
-static void
-singlestep(struct process * proc)
+/* The atomic skip code is mostly taken from GDB.  */
+#ifdef __powerpc__
+/* Instruction masks used during single-stepping of atomic
+ * sequences.  This was lifted from GDB.  */
+#define LWARX_MASK 0xfc0007fe
+#define LWARX_INSTRUCTION 0x7c000028
+#define LDARX_INSTRUCTION 0x7c0000A8
+#define STWCX_MASK 0xfc0007ff
+#define STWCX_INSTRUCTION 0x7c00012d
+#define STDCX_INSTRUCTION 0x7c0001ad
+#define BC_MASK 0xfc000000
+#define BC_INSTRUCTION 0x40000000
+
+static int
+install_atomic_skip(struct process_stopping_handler *self)
 {
+	struct process *proc = self->task_enabling_breakpoint;
+	void *addr = self->breakpoint_being_enabled->addr;
+	debug(1, "pid=%d addr=%p", proc->pid, addr);
+
+	int insn_count;
+	for (insn_count = 0; ; ++insn_count) {
+		addr += 4;
+		unsigned long l = ptrace(PTRACE_PEEKTEXT, proc->pid, addr, 0);
+		if (l == (unsigned long)-1 && errno)
+			return -1;
+		uint32_t insn;
+#ifdef __powerpc64__
+		insn = l >> 32;
+#else
+		insn = l;
+#endif
+
+		/* If we hit a branch instruction, give up.  The
+		 * computation could escape that way and we'd have to
+		 * treat that case specially.  */
+		if ((insn & BC_MASK) == BC_INSTRUCTION) {
+			debug(1, "pid=%d, found branch at %p, giving up",
+			      proc->pid, addr);
+			return -1;
+		}
+
+		if ((insn & STWCX_MASK) == STWCX_INSTRUCTION
+		    || (insn & STWCX_MASK) == STDCX_INSTRUCTION) {
+			debug(1, "pid=%d, found end of atomic block at %p",
+			      proc->pid, addr);
+			break;
+		}
+
+		/* Arbitrary cut-off.  If we didn't find the
+		 * terminating instruction by now, just give up.  */
+		if (insn_count > 16) {
+			debug(1, "pid=%d, couldn't find end of atomic block",
+			      proc->pid);
+			return -1;
+		}
+	}
+
+	/* Put the breakpoint to the next address.  */
+	self->atomic_skip_bp_addr = addr + 4;
+	insert_breakpoint(proc->leader, self->atomic_skip_bp_addr, NULL, 1);
+
+	debug(1, "PTRACE_CONT");
+	ptrace(PTRACE_CONT, proc->pid, 0, 0);
+	return 0;
+}
+#endif /* __powerpc__ */
+
+static int
+singlestep(struct process_stopping_handler *self)
+{
+	struct process *proc = self->task_enabling_breakpoint;
+
+#ifdef __powerpc__
+	/* On PowerPC, we first check whether the original instruction
+	 * was lwarx/ldarx.  If yes, we can't single-step over it,
+	 * instead we have to execute the whole atomic block at once.  */
+	union {
+		uint32_t insn;
+		char buf[4];
+	} u;
+	memcpy(u.buf, self->breakpoint_being_enabled->orig_value,
+	       BREAKPOINT_LENGTH);
+
+	if ((u.insn & LWARX_MASK) == LWARX_INSTRUCTION
+	    || (u.insn & LWARX_MASK) == LDARX_INSTRUCTION)
+		return install_atomic_skip(self);
+
+#endif
+
 	debug(1, "PTRACE_SINGLESTEP");
-	if (ptrace(PTRACE_SINGLESTEP, proc->pid, 0, 0))
+	if (ptrace(PTRACE_SINGLESTEP, proc->pid, 0, 0)) {
 		perror("PTRACE_SINGLESTEP");
+		return -1;
+	}
+	return 0;
+}
+
+static void
+post_singlestep(struct process_stopping_handler *self, struct event **eventp)
+{
+	continue_for_sigstop_delivery(&self->pids);
+
+	if ((*eventp)->thing == LT_EV_BREAKPOINT)
+		*eventp = NULL; // handled
+
+	if (self->atomic_skip_bp_addr != 0)
+		delete_breakpoint(self->task_enabling_breakpoint->leader,
+				  self->atomic_skip_bp_addr);
+
+	self->breakpoint_being_enabled = NULL;
+	self->state = psh_sinking;
 }
 
 /* This event handler is installed when we are in the process of
@@ -569,13 +678,26 @@ process_stopping_on_event(Event_Handler
 		task_info->sysret = 1;
 	}
 
+again:
 	switch (state) {
 	case psh_stopping:
 		/* If everyone is stopped, singlestep.  */
 		if (each_task(leader, &task_blocked, &self->pids) == NULL) {
 			if (sbp->enabled)
 				disable_breakpoint(teb, sbp);
-			singlestep(teb);
+			if (singlestep(self) < 0) {
+			singlestep_error:
+				fprintf(stderr,
+					"%d couldn't singlestep over %s (%p)\n",
+					teb->pid,
+					sbp->libsym ? sbp->libsym->name : NULL,
+					sbp->addr);
+				delete_breakpoint(leader, sbp->addr);
+				post_singlestep(self, &event);
+				state = self->state;
+				goto again;
+			}
+
 			self->state = state = psh_singlestep;
 		}
 		break;
@@ -583,12 +705,12 @@ process_stopping_on_event(Event_Handler
 	case psh_singlestep:
 		/* In singlestep state, breakpoint signifies that we
 		 * have now stepped, and can re-enable the breakpoint.  */
-		if (event != NULL
-		    && task == self->task_enabling_breakpoint) {
+		if (event != NULL && task == teb) {
 
 			/* This is not the singlestep that we are waiting for.  */
 			if (event->thing == LT_EV_SIGNAL) {
-				singlestep(task);
+				if (singlestep(self) < 0)
+					goto singlestep_error;
 				break;
 			}
 
@@ -598,17 +720,11 @@ process_stopping_on_event(Event_Handler
 			if (sbp->enabled)
 				enable_breakpoint(teb, sbp);
 
-			continue_for_sigstop_delivery(&self->pids);
-
-			self->breakpoint_being_enabled = NULL;
-			self->state = state = psh_sinking;
-
-			if (event->thing == LT_EV_BREAKPOINT)
-				event = NULL; // handled
-		} else
-			break;
-
-		/* fall-through */
+			post_singlestep(self, &event);
+			state = self->state;
+			goto again;
+		}
+		break;
 
 	case psh_sinking:
 		if (await_sigstop_delivery(&self->pids, task_info, event))
diff -up ltrace-0.5/sysdeps/linux-gnu/trace.c\~ ltrace-0.5/sysdeps/linux-gnu/trace.c
--- ltrace-0.5/sysdeps/linux-gnu/trace.c~	2012-04-12 18:00:51.959721393 +0200
+++ ltrace-0.5/sysdeps/linux-gnu/trace.c	2012-04-12 19:51:43.573403477 +0200
@@ -637,7 +637,6 @@ post_singlestep(struct process_stopping_
 				  self->atomic_skip_bp_addr);
 
 	self->breakpoint_being_enabled = NULL;
-	self->state = psh_sinking;
 }
 
 /* This event handler is installed when we are in the process of
@@ -678,7 +677,6 @@ process_stopping_on_event(Event_Handler
 		task_info->sysret = 1;
 	}
 
-again:
 	switch (state) {
 	case psh_stopping:
 		/* If everyone is stopped, singlestep.  */
@@ -694,8 +692,7 @@ again:
 					sbp->addr);
 				delete_breakpoint(leader, sbp->addr);
 				post_singlestep(self, &event);
-				state = self->state;
-				goto again;
+				goto psh_sinking;
 			}
 
 			self->state = state = psh_singlestep;
@@ -721,11 +718,12 @@ again:
 				enable_breakpoint(teb, sbp);
 
 			post_singlestep(self, &event);
-			state = self->state;
-			goto again;
+			goto psh_sinking;
 		}
 		break;
 
+	psh_sinking:
+		state = self->state = psh_sinking;
 	case psh_sinking:
 		if (await_sigstop_delivery(&self->pids, task_info, event))
 			process_stopping_done(self, leader);
diff -up ltrace-0.5/testsuite/ltrace.torture/ppc64-lwarx.exp\~ ltrace-0.5/testsuite/ltrace.torture/ppc64-lwarx.exp
--- ltrace-0.5/testsuite/ltrace.torture/ppc64-lwarx.exp~	2012-04-12 17:20:28.945318637 +0200
+++ ltrace-0.5/testsuite/ltrace.torture/ppc64-lwarx.exp	2012-04-12 17:19:56.704335386 +0200
@@ -0,0 +1,55 @@
+# This file is part of ltrace.
+# Copyright (C) 2012 Petr Machata, Red Hat Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+# 02110-1301 USA
+
+set testfile "ppc64-lwarx"
+set srcfile ${testfile}.c
+set binfile ${testfile}
+
+if [get_compiler_info $binfile] {
+  return -1
+}
+
+if { [istarget powerpc*-*] } then {
+    verbose "compiling source file now....."
+    if { [ltrace_compile $srcdir/$subdir/$srcfile $objdir/$subdir/$binfile executable [list debug additional_flags=-O2 ] ] != "" } {
+	 send_user "Testcase compile failed, so all tests in this file will automatically fail\n."
+    }
+
+    # set options for ltrace.
+    ltrace_options "-x" "atomic_add" "-e" "!atoi"
+
+    # Run PUT for ltarce.
+    set exec_output [ltrace_runtest $objdir/$subdir $objdir/$subdir/$binfile]
+
+    # Check the output of this program.
+    verbose "ltrace runtest output: $exec_output\n"
+    if [regexp {ELF from incompatible architecture} $exec_output] {
+	    fail "32-bit ltrace can not perform on 64-bit PUTs and rebuild ltrace in 64 bit mode!"
+	    return 
+    } elseif [ regexp {Couldn't get .hash data} $exec_output ] {
+	    fail "Couldn't get .hash data!"
+	    return
+    }
+
+    set pattern "atomic_add\\\\\\(.*,\\\\\\ 5,.*\\\\\\)"
+    ltrace_verify_output ${objdir}/${subdir}/${testfile}.ltrace $pattern 1
+    set pattern "atomic_add\\\\\\(.*,\\\\\\ 10,.*\\\\\\)"
+    ltrace_verify_output ${objdir}/${subdir}/${testfile}.ltrace $pattern 1
+    set pattern "atomic_add\\\\\\(.*,\\\\\\ 15,.*\\\\\\)"
+    ltrace_verify_output ${objdir}/${subdir}/${testfile}.ltrace $pattern 1
+}
diff -up ltrace-0.5/testsuite/ltrace.torture/ppc64-lwarx.c\~ ltrace-0.5/testsuite/ltrace.torture/ppc64-lwarx.c
--- ltrace-0.5/testsuite/ltrace.torture/ppc64-lwarx.c~	2012-04-12 17:21:34.307311980 +0200
+++ ltrace-0.5/testsuite/ltrace.torture/ppc64-lwarx.c	2012-04-12 17:19:17.163129497 +0200
@@ -0,0 +1,45 @@
+/*
+ * This file is part of ltrace.
+ * Copyright (C) 2012 Petr Machata, Red Hat Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <stdint.h>
+
+__attribute__((noinline)) void
+atomic_add(uint32_t *a, uint32_t b)
+{
+	__asm__ volatile("lwarx 9,0,%0\n"
+			 "add 9,9,%2\n"
+			 "stwcx. 9,0,%0\n"
+			 "bne- atomic_add\n"
+			 : "=r"(a)
+			 : "0"(a), "r"(b)
+			 : "%r9");
+}
+
+uint32_t a = 0;
+
+int
+main(int argc, char **argv)
+{
+	int i;
+	atomic_add(&a, 5);
+	atomic_add(&a, 10);
+	atomic_add(&a, 15);
+	return a;
+}
